From 6855cf3301bee5cf2261c312a5f2857a774b7b24 Mon Sep 17 00:00:00 2001
From: RodgerZhu
Date: Thu, 25 May 2023 19:42:58 +0800
Subject: [PATCH] Add TDVM Encrypted Image Support

---
 demos/encrypted-vm-image/in-vm/assemble.sh    | 37 ++++++++++---------
 .../in-vm/initramfs-hooks/getting_key.sh      | 19 +++++++++-
 .../initramfs-hooks/hook-add-executables      | 12 +++++-
 .../in-vm/initramfs-hooks/hook-unlock         | 10 +++--
 4 files changed, 56 insertions(+), 22 deletions(-)

diff --git a/demos/encrypted-vm-image/in-vm/assemble.sh b/demos/encrypted-vm-image/in-vm/assemble.sh
index 7618884..9a3d684 100755
--- a/demos/encrypted-vm-image/in-vm/assemble.sh
+++ b/demos/encrypted-vm-image/in-vm/assemble.sh
@@ -5,12 +5,11 @@
 
 set -e
 
+#trap cleanup ERR EXIT
 trap cleanup ERR
 
 preset_key="2333"
-
-ref_img_dev="/dev/vda"
-new_img_dev="/dev/sdb"
+new_img_dev=/dev/vdb
 
 LINUX_RESERVED_PART_CODE="8300"
 
@@ -54,7 +53,7 @@ create_disk_partitions()
 {
         local dev=${1}
 
-        [ -z "${dev}" ] && echo "disk device unspecified"
+        [ -z "${dev}" ] && die "disk device unspecified"
 
         sgdisk --zap-all ${dev}
 
@@ -92,10 +91,10 @@ add_fstab_entry()
     local fstab=${1}
     local entry=${2}
 
-    [ -z "${fstab}" ] && echo "fstab location is empty!"
-    [ -z "${entry}" ] && echo "fstab entry is empty!"
+    [ -z "${fstab}" ] && die "fstab location is empty!"
+    [ -z "${entry}" ] && die "fstab entry is empty!"
 
-    [ ! -w "${fstab}" ] && echo "${fstab} is not writable!"
+    [ ! -w "${fstab}" ] && die "${fstab} is not writable!"
 
     # Read the existing fstab entries
     local -a fstab_entries=( "${entry}" )
@@ -112,8 +111,8 @@ run_chroot_cmd()
     local new_root=${1}
     shift
 
-    [ -z "${new_root}" ] && echo "new root directory is empty!"
-    [ ${#} -eq 0 ] && echo "no command specified!"
+    [ -z "${new_root}" ] && die "new root directory is empty!"
+    [ ${#} -eq 0 ] && die "no command specified!"
 
     # Mount /dev and virtual filesystems inside the chroot
     mount --bind /dev ${new_root}/dev
@@ -156,23 +155,24 @@ mkfs.vfat -F 16 -n ${EFI_PART_LABEL} ${efi_partition}
 jindisk_mnt=${jindisk_MNT}
 mkdir -p ${jindisk_mnt}
 
-echo "Prepare Jindisk partition: ${jindisk_partition} ..."
+echo "Prepare jindisk partition: ${jindisk_partition} ..."
 jindisk_partition_size=`blockdev --getsize ${jindisk_partition}`
-echo "Jindisk partition size: "${jindisk_partition_size}
+echo "jindisk partition size: "${jindisk_partition_size}
 
 # sudo jindisksetup-rust create -p ${preset_key} -d ${jindisk_partition} -t jindisk_rootfs
 sudo jindisksetup create ${preset_key} ${jindisk_partition} jindisk_rootfs
 if [ $? -ne 0 ]; then
-	echo "Jindisksetup failed!"
+	echo "jindisksetup failed!"
 	exit -1
 else
-	echo "Jindisk initialized."
+	echo "jindisk initialized."
 fi
 
 # Determine which partition on the reference image contains the rootfs
+ref_img_dev="/dev/vda"
 ref_linux_part=$(get_partition_number ${ref_img_dev} ${LINUX_RESERVED_PART_CODE})
 ref_rootfs=${ref_img_dev}${ref_linux_part}
-echo "Ref image rootfs: ${ref_rootfs}"
+echo ${ref_rootfs}
 
 echo "Filling the new image..."
 dd if=${ref_rootfs} of=/dev/mapper/jindisk_rootfs status=progress
@@ -210,11 +210,14 @@ if [ "${ID}" == "ubuntu" ]; then
         cp -f fstab ${jindisk_mnt}/etc/fstab
         echo "Filling getting_key script..."
         cp -f key.example ${jindisk_mnt}/sbin/
-        #TODO: reading key/certificate using RA script/binary 'getting_key.sh'
         cp -f getting_key.sh ${jindisk_mnt}/sbin/
         echo "Filling opening_disk script..."
         #TODO: entry can be read from /etc/jindisktab
         cp -f opening_disk.sh ${jindisk_mnt}/sbin/
+        # For Remote Attestation
+        unzip ../TDX/ra-client/usr/bin/ra-client.zip -d ../TDX/ra-client/usr/bin/ && rm ../TDX/ra-client/usr/bin/ra-client.zip && cp -rf ../TDX/ra-client/* ${jindisk_mnt}/
+        # For Debug
+        # cp -rf debug/* ${jindisk_mnt}/
     popd
     
     run_chroot_cmd ${jindisk_mnt} update-initramfs -u -k all
@@ -230,10 +233,10 @@ run_chroot_cmd ${jindisk_mnt} grub-install --target=x86_64-efi ${new_img_dev}
 # Update the GRUB menu
 # Disabling os-prober ensures that only the kernels in /boot are added to the menu, and OSes on other disks (like the host OS) are ignored.
 echo "Updating GRUB Menu..."
-cp ${jindisk_mnt}/etc/default/grub ${jindisk_mnt}/etc/default/grub.orig
+cp -rf ./TDX/50-cloudimg-settings.cfg ${jindisk_mnt}/etc/default/grub.d/50-cloudimg-settings.cfg
 echo "GRUB_DISABLE_OS_PROBER=true" >> ${jindisk_mnt}/etc/default/grub
+echo "GRUB_ENABLE_BLSCFG=false" >> ${jindisk_mnt}/etc/default/grub
 run_chroot_cmd ${jindisk_mnt} update-grub
-mv ${jindisk_mnt}/etc/default/grub.orig ${jindisk_mnt}/etc/default/grub
 
 echo "Encrypted Image Successfully Created!"
 exit 0
diff --git a/demos/encrypted-vm-image/in-vm/initramfs-hooks/getting_key.sh b/demos/encrypted-vm-image/in-vm/initramfs-hooks/getting_key.sh
index c405575..ee29cc4 100755
--- a/demos/encrypted-vm-image/in-vm/initramfs-hooks/getting_key.sh
+++ b/demos/encrypted-vm-image/in-vm/initramfs-hooks/getting_key.sh
@@ -1,4 +1,21 @@
 #!/bin/sh
 
-cat /sbin/key.example
+# get key from file
+# cat /sbin/key.example
+
+# get key via RA
+APP_ID=app1
+RA_SERVICE_ADDRESS=ra.service.com:50051
+
+try_count=0
+while [ "$try_count" != "2" ]
+do
+    PASSWORD=`LD_LIBRARY_PATH=/usr/lib GRPC_DEFAULT_SSL_ROOTS_FILE_PATH=/usr/bin/roots.pem /usr/bin/ra-client -host=$RA_SERVICE_ADDRESS -key=$APP_ID | grep 'Secret' | awk -F ': ' '{print $2}'`
+    if [ "$PASSWORD" == "RPC failed" ]; then
+        try_count=$((try_count + 1))
+    else
+        echo $PASSWORD
+        break
+    fi
+done
 
diff --git a/demos/encrypted-vm-image/in-vm/initramfs-hooks/hook-add-executables b/demos/encrypted-vm-image/in-vm/initramfs-hooks/hook-add-executables
index 6c4e325..c3a22d2 100755
--- a/demos/encrypted-vm-image/in-vm/initramfs-hooks/hook-add-executables
+++ b/demos/encrypted-vm-image/in-vm/initramfs-hooks/hook-add-executables
@@ -14,8 +14,18 @@ esac
 
 . /usr/share/initramfs-tools/hook-functions
 
-
 copy_exec /sbin/opening_disk.sh
 copy_exec /sbin/getting_key.sh
 copy_exec /sbin/key.example
 
+# For RA
+copy_exec /etc/hosts
+copy_exec /usr/bin/ra-client
+copy_exec /usr/bin/roots.pem
+copy_exec /usr/bin/dynamic_config.json
+copy_exec /usr/lib/libsgx_urts.so.2
+copy_exec /usr/lib/libsgx_enclave_common.so.1
+# For Debug
+# copy_exec /usr/bin/nm
+# copy_exec /usr/bin/ldd
+# copy_exec /usr/lib/x86_64-linux-gnu/libbfd-2.30-113.el8.so
diff --git a/demos/encrypted-vm-image/in-vm/initramfs-hooks/hook-unlock b/demos/encrypted-vm-image/in-vm/initramfs-hooks/hook-unlock
index 53d5fcc..0b2070f 100755
--- a/demos/encrypted-vm-image/in-vm/initramfs-hooks/hook-unlock
+++ b/demos/encrypted-vm-image/in-vm/initramfs-hooks/hook-unlock
@@ -16,14 +16,16 @@ esac
 
 . /scripts/functions
 
+log_begin_msg "-----------start----configure_networking"
+configure_networking
+log_end_msg "-----------end----configure_networking"
 # Begin real processing below this line
 
-if [ ! -x "/sbin/opening_disk.sh" ]; then
+if [ ! -e "/sbin/opening_disk.sh" ]; then
 	panic "jindisk unlocking executable not found"
 fi
 
-
-log_begin_msg "Mounting jindisk rootfs"
+log_begin_msg "---------------Mounting jindisk rootfs"
 /sbin/opening_disk.sh || panic "jindisk unlocking failed"
 log_end_msg
 
@@ -32,4 +34,6 @@ if [ ! -e "/dev/mapper/jindisk_rootfs" ]; then
 	panic "jindisk rootfs dm target not found"
 fi
 
+# panic "----DEBUG----STOP HERE-------------"
+
 exit 0
-- 
2.27.0

